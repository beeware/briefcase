[33mcommit d7eaaa1976899c21d44ebae06e14b2fa606c70ae[m
Author: kavi2du <kavidu.ab@gmail.com>
Date:   Tue Mar 25 00:07:11 2025 +0800

    Address review comments #2

[1mdiff --git a/changes/2148.feature.rst b/changes/2148.feature.rst[m
[1mindex a53fe647..ea256015 100644[m
[1m--- a/changes/2148.feature.rst[m
[1m+++ b/changes/2148.feature.rst[m
[36m@@ -1 +1 @@[m
[31m-The `build` and `package` commands can now be run on a single or multiple app(s) in a project by using the `-a / --app` option[m
[32m+[m[32mThe `build` and `package` commands can now be run on a single app in a multi-app project by using the `-a / --app` option.[m
[1mdiff --git a/docs/reference/commands/build.rst b/docs/reference/commands/build.rst[m
[1mindex 45692529..b1fd77dc 100644[m
[1m--- a/docs/reference/commands/build.rst[m
[1m+++ b/docs/reference/commands/build.rst[m
[36m@@ -43,6 +43,13 @@[m [mOptions[m
 [m
 The following options can be provided at the command line.[m
 [m
[32m+[m[32m``-a <app name>`` / ``--app <app name>``[m
[32m+[m[32m----------------------------------------[m
[32m+[m
[32m+[m[32mRun a specific application target in your project. This argument is only[m
[32m+[m[32mrequired if your project contains more than one application target. The app[m
[32m+[m[32mname specified should be the machine-readable package name for the app.[m
[32m+[m
 ``-u`` / ``--update``[m
 ---------------------[m
 [m
[1mdiff --git a/docs/reference/commands/package.rst b/docs/reference/commands/package.rst[m
[1mindex cfa08391..23d012c8 100644[m
[1m--- a/docs/reference/commands/package.rst[m
[1m+++ b/docs/reference/commands/package.rst[m
[36m@@ -41,6 +41,13 @@[m [mOptions[m
 [m
 The following options can be provided at the command line.[m
 [m
[32m+[m[32m``-a <app name>`` / ``--app <app name>``[m
[32m+[m[32m----------------------------------------[m
[32m+[m
[32m+[m[32mRun a specific application target in your project. This argument is only[m
[32m+[m[32mrequired if your project contains more than one application target. The app[m
[32m+[m[32mname specified should be the machine-readable package name for the app.[m
[32m+[m
 ``-u`` / ``--update``[m
 ---------------------[m
 [m
[1mdiff --git a/docs/reference/commands/run.rst b/docs/reference/commands/run.rst[m
[1mindex 7dd34ec4..86912bb9 100644[m
[1m--- a/docs/reference/commands/run.rst[m
[1m+++ b/docs/reference/commands/run.rst[m
[36m@@ -60,8 +60,8 @@[m [mOptions[m
 [m
 The following options can be provided at the command line.[m
 [m
[31m-``-a <app name>`` / ``--app <app name``[m
[31m----------------------------------------[m
[32m+[m[32m``-a <app name>`` / ``--app <app name>``[m
[32m+[m[32m----------------------------------------[m
 [m
 Run a specific application target in your project. This argument is only[m
 required if your project contains more than one application target. The app[m
[1mdiff --git a/docs/reference/commands/update.rst b/docs/reference/commands/update.rst[m
[1mindex 977466f1..9eb1cba9 100644[m
[1m--- a/docs/reference/commands/update.rst[m
[1m+++ b/docs/reference/commands/update.rst[m
[36m@@ -36,6 +36,13 @@[m [mOptions[m
 [m
 The following options can be provided at the command line.[m
 [m
[32m+[m[32m``-a <app name>`` / ``--app <app name>``[m
[32m+[m[32m----------------------------------------[m
[32m+[m
[32m+[m[32mRun a specific application target in your project. This argument is only[m
[32m+[m[32mrequired if your project contains more than one application target. The app[m
[32m+[m[32mname specified should be the machine-readable package name for the app.[m
[32m+[m
 ``-r`` / ``--update-requirements``[m
 ----------------------------------[m
 [m
[1mdiff --git a/src/briefcase/commands/build.py b/src/briefcase/commands/build.py[m
[1mindex 1c458496..253569d1 100644[m
[1m--- a/src/briefcase/commands/build.py[m
[1m+++ b/src/briefcase/commands/build.py[m
[36m@@ -17,9 +17,8 @@[m [mclass BuildCommand(BaseCommand):[m
         parser.add_argument([m
             "-a",[m
             "--app",[m
[31m-            dest="apps",[m
[31m-            action="append",[m
[31m-            help="Name of the app(s) to build (if multiple apps exist in the project)",[m
[32m+[m[32m            dest="app_name",[m
[32m+[m[32m            help="Name of the app to build (if multiple apps exist in the project)",[m
         )[m
 [m
     def build_app(self, app: AppConfig, **options):[m
[36m@@ -94,7 +93,7 @@[m [mclass BuildCommand(BaseCommand):[m
     def __call__([m
         self,[m
         app: AppConfig | None = None,[m
[31m-        apps: list[str] | None = None,[m
[32m+[m[32m        app_name: str | None = None,[m
         update: bool = False,[m
         update_requirements: bool = False,[m
         update_resources: bool = False,[m
[36m@@ -132,15 +131,12 @@[m [mclass BuildCommand(BaseCommand):[m
         # and that the app configuration is finalized.[m
         self.finalize(app)[m
 [m
[31m-        if apps:[m
[31m-            selected_apps = {}[m
[31m-            for name in apps:[m
[31m-                if name not in self.apps:[m
[31m-                    raise BriefcaseCommandError([m
[31m-                        f"App '{name}' does not exist in this project."[m
[31m-                    )[m
[31m-                selected_apps[name] = self.apps[name][m
[31m-            apps_to_build = selected_apps[m
[32m+[m[32m        if app_name:[m
[32m+[m[32m            if app_name not in self.apps:[m
[32m+[m[32m                raise BriefcaseCommandError([m
[32m+[m[32m                    f"App '{app_name}' does not exist in this project."[m
[32m+[m[32m                )[m
[32m+[m[32m            apps_to_build = {app_name: self.apps[app_name]}[m
         elif app:[m
             apps_to_build = {app.app_name: app}[m
         else:[m
[1mdiff --git a/src/briefcase/commands/package.py b/src/briefcase/commands/package.py[m
[1mindex 4d23b29d..0046594d 100644[m
[1m--- a/src/briefcase/commands/package.py[m
[1m+++ b/src/briefcase/commands/package.py[m
[36m@@ -122,9 +122,8 @@[m [mclass PackageCommand(BaseCommand):[m
         parser.add_argument([m
             "-a",[m
             "--app",[m
[31m-            dest="apps",[m
[31m-            action="append",[m
[31m-            help="Name of the app(s) to build (if multiple apps exist in the project)",[m
[32m+[m[32m            dest="app_name",[m
[32m+[m[32m            help="Name of the app to package (if multiple apps exist in the project)",[m
         )[m
 [m
         parser.add_argument([m
[36m@@ -160,7 +159,7 @@[m [mclass PackageCommand(BaseCommand):[m
     def __call__([m
         self,[m
         app: AppConfig | None = None,[m
[31m-        apps: list[str] | None = None,[m
[32m+[m[32m        app_name: str | None = None,[m
         update: bool = False,[m
         **options,[m
     ) -> dict | None:[m
[36m@@ -169,15 +168,12 @@[m [mclass PackageCommand(BaseCommand):[m
         # and that the app configuration is finalized.[m
         self.finalize(app)[m
 [m
[31m-        if apps:[m
[31m-            selected_apps = {}[m
[31m-            for name in apps:[m
[31m-                if name not in self.apps:[m
[31m-                    raise BriefcaseCommandError([m
[31m-                        f"App '{name}' does not exist in this project."[m
[31m-                    )[m
[31m-                selected_apps[name] = self.apps[name][m
[31m-            apps_to_package = selected_apps[m
[32m+[m[32m        if app_name:[m
[32m+[m[32m            if app_name not in self.apps:[m
[32m+[m[32m                raise BriefcaseCommandError([m
[32m+[m[32m                    f"App '{app_name}' does not exist in this project."[m
[32m+[m[32m                )[m
[32m+[m[32m            apps_to_package = {app_name: self.apps[app_name]}[m
         elif app:[m
             apps_to_package = {app.app_name: app}[m
         else:[m
[36m@@ -196,7 +192,7 @@[m [mclass PackageCommand(BaseCommand):[m
     def parse_options(self, extra=None):[m
         options, overrides = super().parse_options(extra=extra)[m
 [m
[31m-        if options.get("apps") is None:[m
[31m-            options.pop("apps", None)[m
[32m+[m[32m        if options.get("app_name") is None:[m
[32m+[m[32m            options.pop("app_name", None)[m
 [m
         return options, overrides[m
[1mdiff --git a/tests/commands/build/test_call.py b/tests/commands/build/test_call.py[m
[1mindex 63f7a890..54d49fb7 100644[m
[1m--- a/tests/commands/build/test_call.py[m
[1m+++ b/tests/commands/build/test_call.py[m
[36m@@ -1251,44 +1251,6 @@[m [mdef test_build_app_single(build_command, first_app, second_app):[m
     ][m
 [m
 [m
[31m-def test_build_app_multiple(build_command, first_app, second_app):[m
[31m-    """Multiple --app flags build the specified apps."""[m
[31m-    # Add two apps[m
[31m-    build_command.apps = {[m
[31m-        "first": first_app,[m
[31m-        "second": second_app,[m
[31m-    }[m
[31m-[m
[31m-    # Configure command line options[m
[31m-    options, _ = build_command.parse_options(["--app", "first", "--app", "second"])[m
[31m-[m
[31m-    # Run the build command[m
[31m-    build_command(**options)[m
[31m-[m
[31m-    # The right sequence of things will be done[m
[31m-    assert build_command.actions == [[m
[31m-        # Host OS is verified[m
[31m-        ("verify-host",),[m
[31m-        # Tools are verified[m
[31m-        ("verify-tools",),[m
[31m-        # App configs have been finalized[m
[31m-        ("finalize-app-config", "first"),[m
[31m-        ("finalize-app-config", "second"),[m
[31m-        # App template is verified for first app[m
[31m-        ("verify-app-template", "first"),[m
[31m-        # App tools are verified for first app[m
[31m-        ("verify-app-tools", "first"),[m
[31m-        # Build the first app[m
[31m-        ("build", "first", {"test_mode": False}),[m
[31m-        # App template is verified for second app[m
[31m-        ("verify-app-template", "second"),[m
[31m-        # App tools are verified for second app[m
[31m-        ("verify-app-tools", "second"),[m
[31m-        # Build the second app[m
[31m-        ("build", "second", {"build_state": "first", "test_mode": False}),[m
[31m-    ][m
[31m-[m
[31m-[m
 def test_build_app_invalid(build_command, first_app, second_app):[m
     """If an invalid app name is passed to --app, an error is raised."""[m
     # Add two valid apps[m
[36m@@ -1308,21 +1270,6 @@[m [mdef test_build_app_invalid(build_command, first_app, second_app):[m
         build_command(**options)[m
 [m
 [m
[31m-def test_build_app_duplicate(build_command, first_app):[m
[31m-    """Duplicate --app flags with the same name do not break the build."""[m
[31m-    # Add one app[m
[31m-    build_command.apps = {"first": first_app}[m
[31m-[m
[31m-    # Configure command line options[m
[31m-    options, _ = build_command.parse_options(["--app", "first", "--app", "first"])[m
[31m-[m
[31m-    # Run the build command[m
[31m-    build_command(**options)[m
[31m-[m
[31m-    # The app is built only once[m
[31m-    assert build_command.actions.count(("build", "first", {"test_mode": False})) == 1[m
[31m-[m
[31m-[m
 def test_build_app_none_defined(build_command):[m
     """If no apps are defined, do nothing."""[m
     # No apps available[m
[1mdiff --git a/tests/commands/package/test_call.py b/tests/commands/package/test_call.py[m
[1mindex d7b0ae30..6ba472ab 100644[m
[1m--- a/tests/commands/package/test_call.py[m
[1m+++ b/tests/commands/package/test_call.py[m
[36m@@ -801,59 +801,6 @@[m [mdef test_package_app_single(package_command, first_app):[m
     ][m
 [m
 [m
[31m-def test_package_app_multiple(package_command, first_app, second_app):[m
[31m-    """Multiple --app values only package the selected apps."""[m
[31m-    # Add two apps[m
[31m-    package_command.apps = {[m
[31m-        "first": first_app,[m
[31m-        "second": second_app,[m
[31m-    }[m
[31m-[m
[31m-    # Configure the --app options[m
[31m-    options, _ = package_command.parse_options(["--app", "first", "--app", "second"])[m
[31m-[m
[31m-    # Run the package command[m
[31m-    package_command(**options)[m
[31m-[m
[31m-    # The right sequence of things will be done[m
[31m-    assert package_command.actions == [[m
[31m-        # Host OS is verified[m
[31m-        ("verify-host",),[m
[31m-        # Tools are verified[m
[31m-        ("verify-tools",),[m
[31m-        # App configs have been finalized[m
[31m-        ("finalize-app-config", "first"),[m
[31m-        ("finalize-app-config", "second"),[m
[31m-        # App template is verified for first app[m
[31m-        ("verify-app-template", "first"),[m
[31m-        # App tools are verified for first app[m
[31m-        ("verify-app-tools", "first"),[m
[31m-        # Package the first app[m
[31m-        ([m
[31m-            "package",[m
[31m-            "first",[m
[31m-            {[m
[31m-                "adhoc_sign": False,[m
[31m-                "identity": None,[m
[31m-            },[m
[31m-        ),[m
[31m-        # App template is verified for second app[m
[31m-        ("verify-app-template", "second"),[m
[31m-        # App tools are verified for second app[m
[31m-        ("verify-app-tools", "second"),[m
[31m-        # Package the second app[m
[31m-        ([m
[31m-            "package",[m
[31m-            "second",[m
[31m-            {[m
[31m-                "adhoc_sign": False,[m
[31m-                "identity": None,[m
[31m-                "package_state": "first",[m
[31m-            },[m
[31m-        ),[m
[31m-    ][m
[31m-[m
[31m-[m
 def test_package_app_invalid(package_command, first_app, second_app):[m
     """If an invalid app name is passed to --app, raise an error."""[m
     # Add two apps[m
[36m@@ -873,28 +820,6 @@[m [mdef test_package_app_invalid(package_command, first_app, second_app):[m
         package_command(**options)[m
 [m
 [m
[31m-def test_package_app_duplicate(package_command, first_app):[m
[31m-    """Passing --app multiple times with the same name should not double-package."""[m
[31m-    # Add a single app[m
[31m-    package_command.apps = {[m
[31m-        "first": first_app,[m
[31m-    }[m
[31m-[m
[31m-    # Configure --app with duplicates[m
[31m-    options, _ = package_command.parse_options(["--app", "first", "--app", "first"])[m
[31m-[m
[31m-    # Run the package command[m
[31m-    package_command(**options)[m
[31m-[m
[31m-    # The app should be packaged only once[m
[31m-    assert ([m
[31m-        package_command.actions.count([m
[31m-            ("package", "first", {"adhoc_sign": False, "identity": None})[m
[31m-        )[m
[31m-        == 1[m
[31m-    )[m
[31m-[m
[31m-[m
 def test_package_app_none_defined(package_command):[m
     """Packaging when no apps are defined should be a no-op."""[m
     # No apps defined[m
[36m@@ -916,20 +841,61 @@[m [mdef test_package_app_none_defined(package_command):[m
     ][m
 [m
 [m
[31m-def test_package_with_update(package_command, first_app):[m
[31m-    """If --update is passed, app is updated before packaging."""[m
[32m+[m[32mdef test_package_with_update(package_command, first_app, tmp_path):[m
[32m+[m[32m    """If --update is passed, app is updated, built, and then packaged."""[m
     package_command.apps = {"first": first_app}[m
[32m+[m
[32m+[m[32m    # Provide the --app and --update options[m
     options, _ = package_command.parse_options(["--app", "first", "--update"])[m
     package_command(**options)[m
 [m
[31m-    # Find the 'update' action for the app[m
[31m-    update_action = next([m
[31m-        action[m
[31m-        for action in package_command.actions[m
[31m-        if action[0] == "update" and action[1] == "first"[m
[31m-    )[m
[31m-[m
[31m-    # Assert relevant update flags are True[m
[31m-    assert update_action[2]["update_requirements"] is True[m
[31m-    assert update_action[2]["update_resources"] is True[m
[31m-    assert update_action[2]["update_support"] is True[m
[32m+[m[32m    # Full sequence must include update, build, verify, package[m
[32m+[m[32m    assert package_command.actions == [[m
[32m+[m[32m        # Host OS and tools are verified[m
[32m+[m[32m        ("verify-host",),[m
[32m+[m[32m        ("verify-tools",),[m
[32m+[m[32m        # App config finalized[m
[32m+[m[32m        ("finalize-app-config", "first"),[m
[32m+[m[32m        # App is updated[m
[32m+[m[32m        ([m
[32m+[m[32m            "update",[m
[32m+[m[32m            "first",[m
[32m+[m[32m            {[m
[32m+[m[32m                "adhoc_sign": False,[m
[32m+[m[32m                "identity": None,[m
[32m+[m[32m                "update_requirements": True,[m
[32m+[m[32m                "update_resources": True,[m
[32m+[m[32m                "update_support": True,[m
[32m+[m[32m            },[m
[32m+[m[32m        ),[m
[32m+[m[32m        # App is built[m
[32m+[m[32m        ([m
[32m+[m[32m            "build",[m
[32m+[m[32m            "first",[m
[32m+[m[32m            {[m
[32m+[m[32m                "adhoc_sign": False,[m
[32m+[m[32m                "identity": None,[m
[32m+[m[32m                "update_state": "first",[m
[32m+[m[32m            },[m
[32m+[m[32m        ),[m
[32m+[m[32m        # Template and tools are verified[m
[32m+[m[32m        ("verify-app-template", "first"),[m
[32m+[m[32m        ("verify-app-tools", "first"),[m
[32m+[m[32m        # App is packaged[m
[32m+[m[32m        ([m
[32m+[m[32m            "package",[m
[32m+[m[32m            "first",[m
[32m+[m[32m            {[m
[32m+[m[32m                "adhoc_sign": False,[m
[32m+[m[32m                "identity": None,[m
[32m+[m[32m                "update_state": "first",[m
[32m+[m[32m                "build_state": "first",[m
[32m+[m[32m            },[m
[32m+[m[32m        ),[m
[32m+[m[32m    ][m
[32m+[m
[32m+[m[32m    # Packaging format has been annotated on the app[m
[32m+[m[32m    assert first_app.packaging_format == "pkg"[m
[32m+[m
[32m+[m[32m    # The dist folder has been created[m
[32m+[m[32m    assert tmp_path / "base_path/dist"[m
